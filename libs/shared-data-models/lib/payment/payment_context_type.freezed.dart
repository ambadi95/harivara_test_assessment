// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'payment_context_type.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$PaymentContextTypeTearOff {
  const _$PaymentContextTypeTearOff();

  M2M m2m() {
    return const M2M();
  }

  P2M p2m() {
    return const P2M();
  }

  P2P p2p() {
    return const P2P();
  }
}

/// @nodoc
const $PaymentContextType = _$PaymentContextTypeTearOff();

/// @nodoc
mixin _$PaymentContextType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() m2m,
    required TResult Function() p2m,
    required TResult Function() p2p,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? m2m,
    TResult Function()? p2m,
    TResult Function()? p2p,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? m2m,
    TResult Function()? p2m,
    TResult Function()? p2p,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(M2M value) m2m,
    required TResult Function(P2M value) p2m,
    required TResult Function(P2P value) p2p,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(M2M value)? m2m,
    TResult Function(P2M value)? p2m,
    TResult Function(P2P value)? p2p,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(M2M value)? m2m,
    TResult Function(P2M value)? p2m,
    TResult Function(P2P value)? p2p,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PaymentContextTypeCopyWith<$Res> {
  factory $PaymentContextTypeCopyWith(
          PaymentContextType value, $Res Function(PaymentContextType) then) =
      _$PaymentContextTypeCopyWithImpl<$Res>;
}

/// @nodoc
class _$PaymentContextTypeCopyWithImpl<$Res>
    implements $PaymentContextTypeCopyWith<$Res> {
  _$PaymentContextTypeCopyWithImpl(this._value, this._then);

  final PaymentContextType _value;
  // ignore: unused_field
  final $Res Function(PaymentContextType) _then;
}

/// @nodoc
abstract class $M2MCopyWith<$Res> {
  factory $M2MCopyWith(M2M value, $Res Function(M2M) then) =
      _$M2MCopyWithImpl<$Res>;
}

/// @nodoc
class _$M2MCopyWithImpl<$Res> extends _$PaymentContextTypeCopyWithImpl<$Res>
    implements $M2MCopyWith<$Res> {
  _$M2MCopyWithImpl(M2M _value, $Res Function(M2M) _then)
      : super(_value, (v) => _then(v as M2M));

  @override
  M2M get _value => super._value as M2M;
}

/// @nodoc

class _$M2M extends M2M {
  const _$M2M() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is M2M);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() m2m,
    required TResult Function() p2m,
    required TResult Function() p2p,
  }) {
    return m2m();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? m2m,
    TResult Function()? p2m,
    TResult Function()? p2p,
  }) {
    return m2m?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? m2m,
    TResult Function()? p2m,
    TResult Function()? p2p,
    required TResult orElse(),
  }) {
    if (m2m != null) {
      return m2m();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(M2M value) m2m,
    required TResult Function(P2M value) p2m,
    required TResult Function(P2P value) p2p,
  }) {
    return m2m(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(M2M value)? m2m,
    TResult Function(P2M value)? p2m,
    TResult Function(P2P value)? p2p,
  }) {
    return m2m?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(M2M value)? m2m,
    TResult Function(P2M value)? p2m,
    TResult Function(P2P value)? p2p,
    required TResult orElse(),
  }) {
    if (m2m != null) {
      return m2m(this);
    }
    return orElse();
  }
}

abstract class M2M extends PaymentContextType {
  const factory M2M() = _$M2M;
  const M2M._() : super._();
}

/// @nodoc
abstract class $P2MCopyWith<$Res> {
  factory $P2MCopyWith(P2M value, $Res Function(P2M) then) =
      _$P2MCopyWithImpl<$Res>;
}

/// @nodoc
class _$P2MCopyWithImpl<$Res> extends _$PaymentContextTypeCopyWithImpl<$Res>
    implements $P2MCopyWith<$Res> {
  _$P2MCopyWithImpl(P2M _value, $Res Function(P2M) _then)
      : super(_value, (v) => _then(v as P2M));

  @override
  P2M get _value => super._value as P2M;
}

/// @nodoc

class _$P2M extends P2M {
  const _$P2M() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is P2M);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() m2m,
    required TResult Function() p2m,
    required TResult Function() p2p,
  }) {
    return p2m();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? m2m,
    TResult Function()? p2m,
    TResult Function()? p2p,
  }) {
    return p2m?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? m2m,
    TResult Function()? p2m,
    TResult Function()? p2p,
    required TResult orElse(),
  }) {
    if (p2m != null) {
      return p2m();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(M2M value) m2m,
    required TResult Function(P2M value) p2m,
    required TResult Function(P2P value) p2p,
  }) {
    return p2m(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(M2M value)? m2m,
    TResult Function(P2M value)? p2m,
    TResult Function(P2P value)? p2p,
  }) {
    return p2m?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(M2M value)? m2m,
    TResult Function(P2M value)? p2m,
    TResult Function(P2P value)? p2p,
    required TResult orElse(),
  }) {
    if (p2m != null) {
      return p2m(this);
    }
    return orElse();
  }
}

abstract class P2M extends PaymentContextType {
  const factory P2M() = _$P2M;
  const P2M._() : super._();
}

/// @nodoc
abstract class $P2PCopyWith<$Res> {
  factory $P2PCopyWith(P2P value, $Res Function(P2P) then) =
      _$P2PCopyWithImpl<$Res>;
}

/// @nodoc
class _$P2PCopyWithImpl<$Res> extends _$PaymentContextTypeCopyWithImpl<$Res>
    implements $P2PCopyWith<$Res> {
  _$P2PCopyWithImpl(P2P _value, $Res Function(P2P) _then)
      : super(_value, (v) => _then(v as P2P));

  @override
  P2P get _value => super._value as P2P;
}

/// @nodoc

class _$P2P extends P2P {
  const _$P2P() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is P2P);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() m2m,
    required TResult Function() p2m,
    required TResult Function() p2p,
  }) {
    return p2p();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? m2m,
    TResult Function()? p2m,
    TResult Function()? p2p,
  }) {
    return p2p?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? m2m,
    TResult Function()? p2m,
    TResult Function()? p2p,
    required TResult orElse(),
  }) {
    if (p2p != null) {
      return p2p();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(M2M value) m2m,
    required TResult Function(P2M value) p2m,
    required TResult Function(P2P value) p2p,
  }) {
    return p2p(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(M2M value)? m2m,
    TResult Function(P2M value)? p2m,
    TResult Function(P2P value)? p2p,
  }) {
    return p2p?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(M2M value)? m2m,
    TResult Function(P2M value)? p2m,
    TResult Function(P2P value)? p2p,
    required TResult orElse(),
  }) {
    if (p2p != null) {
      return p2p(this);
    }
    return orElse();
  }
}

abstract class P2P extends PaymentContextType {
  const factory P2P() = _$P2P;
  const P2P._() : super._();
}
