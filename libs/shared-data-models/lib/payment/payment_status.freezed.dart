// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'payment_status.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$PaymentStatus {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() abandoned,
    required TResult Function() authorized,
    required TResult Function() cancelled,
    required TResult Function() captured,
    required TResult Function() verified,
    required TResult Function() declined,
    required TResult Function() failed,
    required TResult Function() paid,
    required TResult Function() pending,
    required TResult Function() restricted,
    required TResult Function() timeout,
    required TResult Function() unknown,
    required TResult Function() voidStatus,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Abandoned value) abandoned,
    required TResult Function(Authorized value) authorized,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Captured value) captured,
    required TResult Function(Verified value) verified,
    required TResult Function(Declined value) declined,
    required TResult Function(Failed value) failed,
    required TResult Function(Paid value) paid,
    required TResult Function(Pending value) pending,
    required TResult Function(Restricted value) restricted,
    required TResult Function(PaymentTimeout value) timeout,
    required TResult Function(PaymentUnknown value) unknown,
    required TResult Function(VoidPayment value) voidStatus,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PaymentStatusCopyWith<$Res> {
  factory $PaymentStatusCopyWith(
          PaymentStatus value, $Res Function(PaymentStatus) then) =
      _$PaymentStatusCopyWithImpl<$Res>;
}

/// @nodoc
class _$PaymentStatusCopyWithImpl<$Res>
    implements $PaymentStatusCopyWith<$Res> {
  _$PaymentStatusCopyWithImpl(this._value, this._then);

  final PaymentStatus _value;
  // ignore: unused_field
  final $Res Function(PaymentStatus) _then;
}

/// @nodoc
abstract class _$$AbandonedCopyWith<$Res> {
  factory _$$AbandonedCopyWith(
          _$Abandoned value, $Res Function(_$Abandoned) then) =
      __$$AbandonedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AbandonedCopyWithImpl<$Res> extends _$PaymentStatusCopyWithImpl<$Res>
    implements _$$AbandonedCopyWith<$Res> {
  __$$AbandonedCopyWithImpl(
      _$Abandoned _value, $Res Function(_$Abandoned) _then)
      : super(_value, (v) => _then(v as _$Abandoned));

  @override
  _$Abandoned get _value => super._value as _$Abandoned;
}

/// @nodoc

class _$Abandoned extends Abandoned {
  const _$Abandoned() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Abandoned);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() abandoned,
    required TResult Function() authorized,
    required TResult Function() cancelled,
    required TResult Function() captured,
    required TResult Function() verified,
    required TResult Function() declined,
    required TResult Function() failed,
    required TResult Function() paid,
    required TResult Function() pending,
    required TResult Function() restricted,
    required TResult Function() timeout,
    required TResult Function() unknown,
    required TResult Function() voidStatus,
  }) {
    return abandoned();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
  }) {
    return abandoned?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
    required TResult orElse(),
  }) {
    if (abandoned != null) {
      return abandoned();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Abandoned value) abandoned,
    required TResult Function(Authorized value) authorized,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Captured value) captured,
    required TResult Function(Verified value) verified,
    required TResult Function(Declined value) declined,
    required TResult Function(Failed value) failed,
    required TResult Function(Paid value) paid,
    required TResult Function(Pending value) pending,
    required TResult Function(Restricted value) restricted,
    required TResult Function(PaymentTimeout value) timeout,
    required TResult Function(PaymentUnknown value) unknown,
    required TResult Function(VoidPayment value) voidStatus,
  }) {
    return abandoned(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
  }) {
    return abandoned?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
    required TResult orElse(),
  }) {
    if (abandoned != null) {
      return abandoned(this);
    }
    return orElse();
  }
}

abstract class Abandoned extends PaymentStatus {
  const factory Abandoned() = _$Abandoned;
  const Abandoned._() : super._();
}

/// @nodoc
abstract class _$$AuthorizedCopyWith<$Res> {
  factory _$$AuthorizedCopyWith(
          _$Authorized value, $Res Function(_$Authorized) then) =
      __$$AuthorizedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AuthorizedCopyWithImpl<$Res> extends _$PaymentStatusCopyWithImpl<$Res>
    implements _$$AuthorizedCopyWith<$Res> {
  __$$AuthorizedCopyWithImpl(
      _$Authorized _value, $Res Function(_$Authorized) _then)
      : super(_value, (v) => _then(v as _$Authorized));

  @override
  _$Authorized get _value => super._value as _$Authorized;
}

/// @nodoc

class _$Authorized extends Authorized {
  const _$Authorized() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Authorized);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() abandoned,
    required TResult Function() authorized,
    required TResult Function() cancelled,
    required TResult Function() captured,
    required TResult Function() verified,
    required TResult Function() declined,
    required TResult Function() failed,
    required TResult Function() paid,
    required TResult Function() pending,
    required TResult Function() restricted,
    required TResult Function() timeout,
    required TResult Function() unknown,
    required TResult Function() voidStatus,
  }) {
    return authorized();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
  }) {
    return authorized?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
    required TResult orElse(),
  }) {
    if (authorized != null) {
      return authorized();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Abandoned value) abandoned,
    required TResult Function(Authorized value) authorized,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Captured value) captured,
    required TResult Function(Verified value) verified,
    required TResult Function(Declined value) declined,
    required TResult Function(Failed value) failed,
    required TResult Function(Paid value) paid,
    required TResult Function(Pending value) pending,
    required TResult Function(Restricted value) restricted,
    required TResult Function(PaymentTimeout value) timeout,
    required TResult Function(PaymentUnknown value) unknown,
    required TResult Function(VoidPayment value) voidStatus,
  }) {
    return authorized(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
  }) {
    return authorized?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
    required TResult orElse(),
  }) {
    if (authorized != null) {
      return authorized(this);
    }
    return orElse();
  }
}

abstract class Authorized extends PaymentStatus {
  const factory Authorized() = _$Authorized;
  const Authorized._() : super._();
}

/// @nodoc
abstract class _$$CancelledCopyWith<$Res> {
  factory _$$CancelledCopyWith(
          _$Cancelled value, $Res Function(_$Cancelled) then) =
      __$$CancelledCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CancelledCopyWithImpl<$Res> extends _$PaymentStatusCopyWithImpl<$Res>
    implements _$$CancelledCopyWith<$Res> {
  __$$CancelledCopyWithImpl(
      _$Cancelled _value, $Res Function(_$Cancelled) _then)
      : super(_value, (v) => _then(v as _$Cancelled));

  @override
  _$Cancelled get _value => super._value as _$Cancelled;
}

/// @nodoc

class _$Cancelled extends Cancelled {
  const _$Cancelled() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Cancelled);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() abandoned,
    required TResult Function() authorized,
    required TResult Function() cancelled,
    required TResult Function() captured,
    required TResult Function() verified,
    required TResult Function() declined,
    required TResult Function() failed,
    required TResult Function() paid,
    required TResult Function() pending,
    required TResult Function() restricted,
    required TResult Function() timeout,
    required TResult Function() unknown,
    required TResult Function() voidStatus,
  }) {
    return cancelled();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
  }) {
    return cancelled?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
    required TResult orElse(),
  }) {
    if (cancelled != null) {
      return cancelled();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Abandoned value) abandoned,
    required TResult Function(Authorized value) authorized,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Captured value) captured,
    required TResult Function(Verified value) verified,
    required TResult Function(Declined value) declined,
    required TResult Function(Failed value) failed,
    required TResult Function(Paid value) paid,
    required TResult Function(Pending value) pending,
    required TResult Function(Restricted value) restricted,
    required TResult Function(PaymentTimeout value) timeout,
    required TResult Function(PaymentUnknown value) unknown,
    required TResult Function(VoidPayment value) voidStatus,
  }) {
    return cancelled(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
  }) {
    return cancelled?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
    required TResult orElse(),
  }) {
    if (cancelled != null) {
      return cancelled(this);
    }
    return orElse();
  }
}

abstract class Cancelled extends PaymentStatus {
  const factory Cancelled() = _$Cancelled;
  const Cancelled._() : super._();
}

/// @nodoc
abstract class _$$CapturedCopyWith<$Res> {
  factory _$$CapturedCopyWith(
          _$Captured value, $Res Function(_$Captured) then) =
      __$$CapturedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CapturedCopyWithImpl<$Res> extends _$PaymentStatusCopyWithImpl<$Res>
    implements _$$CapturedCopyWith<$Res> {
  __$$CapturedCopyWithImpl(_$Captured _value, $Res Function(_$Captured) _then)
      : super(_value, (v) => _then(v as _$Captured));

  @override
  _$Captured get _value => super._value as _$Captured;
}

/// @nodoc

class _$Captured extends Captured {
  const _$Captured() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Captured);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() abandoned,
    required TResult Function() authorized,
    required TResult Function() cancelled,
    required TResult Function() captured,
    required TResult Function() verified,
    required TResult Function() declined,
    required TResult Function() failed,
    required TResult Function() paid,
    required TResult Function() pending,
    required TResult Function() restricted,
    required TResult Function() timeout,
    required TResult Function() unknown,
    required TResult Function() voidStatus,
  }) {
    return captured();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
  }) {
    return captured?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
    required TResult orElse(),
  }) {
    if (captured != null) {
      return captured();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Abandoned value) abandoned,
    required TResult Function(Authorized value) authorized,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Captured value) captured,
    required TResult Function(Verified value) verified,
    required TResult Function(Declined value) declined,
    required TResult Function(Failed value) failed,
    required TResult Function(Paid value) paid,
    required TResult Function(Pending value) pending,
    required TResult Function(Restricted value) restricted,
    required TResult Function(PaymentTimeout value) timeout,
    required TResult Function(PaymentUnknown value) unknown,
    required TResult Function(VoidPayment value) voidStatus,
  }) {
    return captured(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
  }) {
    return captured?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
    required TResult orElse(),
  }) {
    if (captured != null) {
      return captured(this);
    }
    return orElse();
  }
}

abstract class Captured extends PaymentStatus {
  const factory Captured() = _$Captured;
  const Captured._() : super._();
}

/// @nodoc
abstract class _$$VerifiedCopyWith<$Res> {
  factory _$$VerifiedCopyWith(
          _$Verified value, $Res Function(_$Verified) then) =
      __$$VerifiedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$VerifiedCopyWithImpl<$Res> extends _$PaymentStatusCopyWithImpl<$Res>
    implements _$$VerifiedCopyWith<$Res> {
  __$$VerifiedCopyWithImpl(_$Verified _value, $Res Function(_$Verified) _then)
      : super(_value, (v) => _then(v as _$Verified));

  @override
  _$Verified get _value => super._value as _$Verified;
}

/// @nodoc

class _$Verified extends Verified {
  const _$Verified() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Verified);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() abandoned,
    required TResult Function() authorized,
    required TResult Function() cancelled,
    required TResult Function() captured,
    required TResult Function() verified,
    required TResult Function() declined,
    required TResult Function() failed,
    required TResult Function() paid,
    required TResult Function() pending,
    required TResult Function() restricted,
    required TResult Function() timeout,
    required TResult Function() unknown,
    required TResult Function() voidStatus,
  }) {
    return verified();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
  }) {
    return verified?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
    required TResult orElse(),
  }) {
    if (verified != null) {
      return verified();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Abandoned value) abandoned,
    required TResult Function(Authorized value) authorized,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Captured value) captured,
    required TResult Function(Verified value) verified,
    required TResult Function(Declined value) declined,
    required TResult Function(Failed value) failed,
    required TResult Function(Paid value) paid,
    required TResult Function(Pending value) pending,
    required TResult Function(Restricted value) restricted,
    required TResult Function(PaymentTimeout value) timeout,
    required TResult Function(PaymentUnknown value) unknown,
    required TResult Function(VoidPayment value) voidStatus,
  }) {
    return verified(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
  }) {
    return verified?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
    required TResult orElse(),
  }) {
    if (verified != null) {
      return verified(this);
    }
    return orElse();
  }
}

abstract class Verified extends PaymentStatus {
  const factory Verified() = _$Verified;
  const Verified._() : super._();
}

/// @nodoc
abstract class _$$DeclinedCopyWith<$Res> {
  factory _$$DeclinedCopyWith(
          _$Declined value, $Res Function(_$Declined) then) =
      __$$DeclinedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DeclinedCopyWithImpl<$Res> extends _$PaymentStatusCopyWithImpl<$Res>
    implements _$$DeclinedCopyWith<$Res> {
  __$$DeclinedCopyWithImpl(_$Declined _value, $Res Function(_$Declined) _then)
      : super(_value, (v) => _then(v as _$Declined));

  @override
  _$Declined get _value => super._value as _$Declined;
}

/// @nodoc

class _$Declined extends Declined {
  const _$Declined() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Declined);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() abandoned,
    required TResult Function() authorized,
    required TResult Function() cancelled,
    required TResult Function() captured,
    required TResult Function() verified,
    required TResult Function() declined,
    required TResult Function() failed,
    required TResult Function() paid,
    required TResult Function() pending,
    required TResult Function() restricted,
    required TResult Function() timeout,
    required TResult Function() unknown,
    required TResult Function() voidStatus,
  }) {
    return declined();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
  }) {
    return declined?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
    required TResult orElse(),
  }) {
    if (declined != null) {
      return declined();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Abandoned value) abandoned,
    required TResult Function(Authorized value) authorized,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Captured value) captured,
    required TResult Function(Verified value) verified,
    required TResult Function(Declined value) declined,
    required TResult Function(Failed value) failed,
    required TResult Function(Paid value) paid,
    required TResult Function(Pending value) pending,
    required TResult Function(Restricted value) restricted,
    required TResult Function(PaymentTimeout value) timeout,
    required TResult Function(PaymentUnknown value) unknown,
    required TResult Function(VoidPayment value) voidStatus,
  }) {
    return declined(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
  }) {
    return declined?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
    required TResult orElse(),
  }) {
    if (declined != null) {
      return declined(this);
    }
    return orElse();
  }
}

abstract class Declined extends PaymentStatus {
  const factory Declined() = _$Declined;
  const Declined._() : super._();
}

/// @nodoc
abstract class _$$FailedCopyWith<$Res> {
  factory _$$FailedCopyWith(_$Failed value, $Res Function(_$Failed) then) =
      __$$FailedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FailedCopyWithImpl<$Res> extends _$PaymentStatusCopyWithImpl<$Res>
    implements _$$FailedCopyWith<$Res> {
  __$$FailedCopyWithImpl(_$Failed _value, $Res Function(_$Failed) _then)
      : super(_value, (v) => _then(v as _$Failed));

  @override
  _$Failed get _value => super._value as _$Failed;
}

/// @nodoc

class _$Failed extends Failed {
  const _$Failed() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Failed);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() abandoned,
    required TResult Function() authorized,
    required TResult Function() cancelled,
    required TResult Function() captured,
    required TResult Function() verified,
    required TResult Function() declined,
    required TResult Function() failed,
    required TResult Function() paid,
    required TResult Function() pending,
    required TResult Function() restricted,
    required TResult Function() timeout,
    required TResult Function() unknown,
    required TResult Function() voidStatus,
  }) {
    return failed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
  }) {
    return failed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
    required TResult orElse(),
  }) {
    if (failed != null) {
      return failed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Abandoned value) abandoned,
    required TResult Function(Authorized value) authorized,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Captured value) captured,
    required TResult Function(Verified value) verified,
    required TResult Function(Declined value) declined,
    required TResult Function(Failed value) failed,
    required TResult Function(Paid value) paid,
    required TResult Function(Pending value) pending,
    required TResult Function(Restricted value) restricted,
    required TResult Function(PaymentTimeout value) timeout,
    required TResult Function(PaymentUnknown value) unknown,
    required TResult Function(VoidPayment value) voidStatus,
  }) {
    return failed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
  }) {
    return failed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
    required TResult orElse(),
  }) {
    if (failed != null) {
      return failed(this);
    }
    return orElse();
  }
}

abstract class Failed extends PaymentStatus {
  const factory Failed() = _$Failed;
  const Failed._() : super._();
}

/// @nodoc
abstract class _$$PaidCopyWith<$Res> {
  factory _$$PaidCopyWith(_$Paid value, $Res Function(_$Paid) then) =
      __$$PaidCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaidCopyWithImpl<$Res> extends _$PaymentStatusCopyWithImpl<$Res>
    implements _$$PaidCopyWith<$Res> {
  __$$PaidCopyWithImpl(_$Paid _value, $Res Function(_$Paid) _then)
      : super(_value, (v) => _then(v as _$Paid));

  @override
  _$Paid get _value => super._value as _$Paid;
}

/// @nodoc

class _$Paid extends Paid {
  const _$Paid() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Paid);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() abandoned,
    required TResult Function() authorized,
    required TResult Function() cancelled,
    required TResult Function() captured,
    required TResult Function() verified,
    required TResult Function() declined,
    required TResult Function() failed,
    required TResult Function() paid,
    required TResult Function() pending,
    required TResult Function() restricted,
    required TResult Function() timeout,
    required TResult Function() unknown,
    required TResult Function() voidStatus,
  }) {
    return paid();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
  }) {
    return paid?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
    required TResult orElse(),
  }) {
    if (paid != null) {
      return paid();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Abandoned value) abandoned,
    required TResult Function(Authorized value) authorized,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Captured value) captured,
    required TResult Function(Verified value) verified,
    required TResult Function(Declined value) declined,
    required TResult Function(Failed value) failed,
    required TResult Function(Paid value) paid,
    required TResult Function(Pending value) pending,
    required TResult Function(Restricted value) restricted,
    required TResult Function(PaymentTimeout value) timeout,
    required TResult Function(PaymentUnknown value) unknown,
    required TResult Function(VoidPayment value) voidStatus,
  }) {
    return paid(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
  }) {
    return paid?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
    required TResult orElse(),
  }) {
    if (paid != null) {
      return paid(this);
    }
    return orElse();
  }
}

abstract class Paid extends PaymentStatus {
  const factory Paid() = _$Paid;
  const Paid._() : super._();
}

/// @nodoc
abstract class _$$PendingCopyWith<$Res> {
  factory _$$PendingCopyWith(_$Pending value, $Res Function(_$Pending) then) =
      __$$PendingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PendingCopyWithImpl<$Res> extends _$PaymentStatusCopyWithImpl<$Res>
    implements _$$PendingCopyWith<$Res> {
  __$$PendingCopyWithImpl(_$Pending _value, $Res Function(_$Pending) _then)
      : super(_value, (v) => _then(v as _$Pending));

  @override
  _$Pending get _value => super._value as _$Pending;
}

/// @nodoc

class _$Pending extends Pending {
  const _$Pending() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Pending);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() abandoned,
    required TResult Function() authorized,
    required TResult Function() cancelled,
    required TResult Function() captured,
    required TResult Function() verified,
    required TResult Function() declined,
    required TResult Function() failed,
    required TResult Function() paid,
    required TResult Function() pending,
    required TResult Function() restricted,
    required TResult Function() timeout,
    required TResult Function() unknown,
    required TResult Function() voidStatus,
  }) {
    return pending();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
  }) {
    return pending?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
    required TResult orElse(),
  }) {
    if (pending != null) {
      return pending();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Abandoned value) abandoned,
    required TResult Function(Authorized value) authorized,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Captured value) captured,
    required TResult Function(Verified value) verified,
    required TResult Function(Declined value) declined,
    required TResult Function(Failed value) failed,
    required TResult Function(Paid value) paid,
    required TResult Function(Pending value) pending,
    required TResult Function(Restricted value) restricted,
    required TResult Function(PaymentTimeout value) timeout,
    required TResult Function(PaymentUnknown value) unknown,
    required TResult Function(VoidPayment value) voidStatus,
  }) {
    return pending(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
  }) {
    return pending?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
    required TResult orElse(),
  }) {
    if (pending != null) {
      return pending(this);
    }
    return orElse();
  }
}

abstract class Pending extends PaymentStatus {
  const factory Pending() = _$Pending;
  const Pending._() : super._();
}

/// @nodoc
abstract class _$$RestrictedCopyWith<$Res> {
  factory _$$RestrictedCopyWith(
          _$Restricted value, $Res Function(_$Restricted) then) =
      __$$RestrictedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RestrictedCopyWithImpl<$Res> extends _$PaymentStatusCopyWithImpl<$Res>
    implements _$$RestrictedCopyWith<$Res> {
  __$$RestrictedCopyWithImpl(
      _$Restricted _value, $Res Function(_$Restricted) _then)
      : super(_value, (v) => _then(v as _$Restricted));

  @override
  _$Restricted get _value => super._value as _$Restricted;
}

/// @nodoc

class _$Restricted extends Restricted {
  const _$Restricted() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Restricted);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() abandoned,
    required TResult Function() authorized,
    required TResult Function() cancelled,
    required TResult Function() captured,
    required TResult Function() verified,
    required TResult Function() declined,
    required TResult Function() failed,
    required TResult Function() paid,
    required TResult Function() pending,
    required TResult Function() restricted,
    required TResult Function() timeout,
    required TResult Function() unknown,
    required TResult Function() voidStatus,
  }) {
    return restricted();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
  }) {
    return restricted?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
    required TResult orElse(),
  }) {
    if (restricted != null) {
      return restricted();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Abandoned value) abandoned,
    required TResult Function(Authorized value) authorized,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Captured value) captured,
    required TResult Function(Verified value) verified,
    required TResult Function(Declined value) declined,
    required TResult Function(Failed value) failed,
    required TResult Function(Paid value) paid,
    required TResult Function(Pending value) pending,
    required TResult Function(Restricted value) restricted,
    required TResult Function(PaymentTimeout value) timeout,
    required TResult Function(PaymentUnknown value) unknown,
    required TResult Function(VoidPayment value) voidStatus,
  }) {
    return restricted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
  }) {
    return restricted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
    required TResult orElse(),
  }) {
    if (restricted != null) {
      return restricted(this);
    }
    return orElse();
  }
}

abstract class Restricted extends PaymentStatus {
  const factory Restricted() = _$Restricted;
  const Restricted._() : super._();
}

/// @nodoc
abstract class _$$PaymentTimeoutCopyWith<$Res> {
  factory _$$PaymentTimeoutCopyWith(
          _$PaymentTimeout value, $Res Function(_$PaymentTimeout) then) =
      __$$PaymentTimeoutCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaymentTimeoutCopyWithImpl<$Res>
    extends _$PaymentStatusCopyWithImpl<$Res>
    implements _$$PaymentTimeoutCopyWith<$Res> {
  __$$PaymentTimeoutCopyWithImpl(
      _$PaymentTimeout _value, $Res Function(_$PaymentTimeout) _then)
      : super(_value, (v) => _then(v as _$PaymentTimeout));

  @override
  _$PaymentTimeout get _value => super._value as _$PaymentTimeout;
}

/// @nodoc

class _$PaymentTimeout extends PaymentTimeout {
  const _$PaymentTimeout() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PaymentTimeout);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() abandoned,
    required TResult Function() authorized,
    required TResult Function() cancelled,
    required TResult Function() captured,
    required TResult Function() verified,
    required TResult Function() declined,
    required TResult Function() failed,
    required TResult Function() paid,
    required TResult Function() pending,
    required TResult Function() restricted,
    required TResult Function() timeout,
    required TResult Function() unknown,
    required TResult Function() voidStatus,
  }) {
    return timeout();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
  }) {
    return timeout?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
    required TResult orElse(),
  }) {
    if (timeout != null) {
      return timeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Abandoned value) abandoned,
    required TResult Function(Authorized value) authorized,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Captured value) captured,
    required TResult Function(Verified value) verified,
    required TResult Function(Declined value) declined,
    required TResult Function(Failed value) failed,
    required TResult Function(Paid value) paid,
    required TResult Function(Pending value) pending,
    required TResult Function(Restricted value) restricted,
    required TResult Function(PaymentTimeout value) timeout,
    required TResult Function(PaymentUnknown value) unknown,
    required TResult Function(VoidPayment value) voidStatus,
  }) {
    return timeout(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
  }) {
    return timeout?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
    required TResult orElse(),
  }) {
    if (timeout != null) {
      return timeout(this);
    }
    return orElse();
  }
}

abstract class PaymentTimeout extends PaymentStatus {
  const factory PaymentTimeout() = _$PaymentTimeout;
  const PaymentTimeout._() : super._();
}

/// @nodoc
abstract class _$$PaymentUnknownCopyWith<$Res> {
  factory _$$PaymentUnknownCopyWith(
          _$PaymentUnknown value, $Res Function(_$PaymentUnknown) then) =
      __$$PaymentUnknownCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaymentUnknownCopyWithImpl<$Res>
    extends _$PaymentStatusCopyWithImpl<$Res>
    implements _$$PaymentUnknownCopyWith<$Res> {
  __$$PaymentUnknownCopyWithImpl(
      _$PaymentUnknown _value, $Res Function(_$PaymentUnknown) _then)
      : super(_value, (v) => _then(v as _$PaymentUnknown));

  @override
  _$PaymentUnknown get _value => super._value as _$PaymentUnknown;
}

/// @nodoc

class _$PaymentUnknown extends PaymentUnknown {
  const _$PaymentUnknown() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PaymentUnknown);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() abandoned,
    required TResult Function() authorized,
    required TResult Function() cancelled,
    required TResult Function() captured,
    required TResult Function() verified,
    required TResult Function() declined,
    required TResult Function() failed,
    required TResult Function() paid,
    required TResult Function() pending,
    required TResult Function() restricted,
    required TResult Function() timeout,
    required TResult Function() unknown,
    required TResult Function() voidStatus,
  }) {
    return unknown();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
  }) {
    return unknown?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Abandoned value) abandoned,
    required TResult Function(Authorized value) authorized,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Captured value) captured,
    required TResult Function(Verified value) verified,
    required TResult Function(Declined value) declined,
    required TResult Function(Failed value) failed,
    required TResult Function(Paid value) paid,
    required TResult Function(Pending value) pending,
    required TResult Function(Restricted value) restricted,
    required TResult Function(PaymentTimeout value) timeout,
    required TResult Function(PaymentUnknown value) unknown,
    required TResult Function(VoidPayment value) voidStatus,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class PaymentUnknown extends PaymentStatus {
  const factory PaymentUnknown() = _$PaymentUnknown;
  const PaymentUnknown._() : super._();
}

/// @nodoc
abstract class _$$VoidPaymentCopyWith<$Res> {
  factory _$$VoidPaymentCopyWith(
          _$VoidPayment value, $Res Function(_$VoidPayment) then) =
      __$$VoidPaymentCopyWithImpl<$Res>;
}

/// @nodoc
class __$$VoidPaymentCopyWithImpl<$Res>
    extends _$PaymentStatusCopyWithImpl<$Res>
    implements _$$VoidPaymentCopyWith<$Res> {
  __$$VoidPaymentCopyWithImpl(
      _$VoidPayment _value, $Res Function(_$VoidPayment) _then)
      : super(_value, (v) => _then(v as _$VoidPayment));

  @override
  _$VoidPayment get _value => super._value as _$VoidPayment;
}

/// @nodoc

class _$VoidPayment extends VoidPayment {
  const _$VoidPayment() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$VoidPayment);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() abandoned,
    required TResult Function() authorized,
    required TResult Function() cancelled,
    required TResult Function() captured,
    required TResult Function() verified,
    required TResult Function() declined,
    required TResult Function() failed,
    required TResult Function() paid,
    required TResult Function() pending,
    required TResult Function() restricted,
    required TResult Function() timeout,
    required TResult Function() unknown,
    required TResult Function() voidStatus,
  }) {
    return voidStatus();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
  }) {
    return voidStatus?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
    required TResult orElse(),
  }) {
    if (voidStatus != null) {
      return voidStatus();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Abandoned value) abandoned,
    required TResult Function(Authorized value) authorized,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Captured value) captured,
    required TResult Function(Verified value) verified,
    required TResult Function(Declined value) declined,
    required TResult Function(Failed value) failed,
    required TResult Function(Paid value) paid,
    required TResult Function(Pending value) pending,
    required TResult Function(Restricted value) restricted,
    required TResult Function(PaymentTimeout value) timeout,
    required TResult Function(PaymentUnknown value) unknown,
    required TResult Function(VoidPayment value) voidStatus,
  }) {
    return voidStatus(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
  }) {
    return voidStatus?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
    required TResult orElse(),
  }) {
    if (voidStatus != null) {
      return voidStatus(this);
    }
    return orElse();
  }
}

abstract class VoidPayment extends PaymentStatus {
  const factory VoidPayment() = _$VoidPayment;
  const VoidPayment._() : super._();
}
