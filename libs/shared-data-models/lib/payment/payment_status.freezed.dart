// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'payment_status.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$PaymentStatusTearOff {
  const _$PaymentStatusTearOff();

  Abandoned abandoned() {
    return const Abandoned();
  }

  Authorized authorized() {
    return const Authorized();
  }

  Cancelled cancelled() {
    return const Cancelled();
  }

  Captured captured() {
    return const Captured();
  }

  Verified verified() {
    return const Verified();
  }

  Declined declined() {
    return const Declined();
  }

  Failed failed() {
    return const Failed();
  }

  Paid paid() {
    return const Paid();
  }

  Pending pending() {
    return const Pending();
  }

  Restricted restricted() {
    return const Restricted();
  }

  PaymentTimeout timeout() {
    return const PaymentTimeout();
  }

  PaymentUnknown unknown() {
    return const PaymentUnknown();
  }

  VoidPayment voidStatus() {
    return const VoidPayment();
  }
}

/// @nodoc
const $PaymentStatus = _$PaymentStatusTearOff();

/// @nodoc
mixin _$PaymentStatus {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() abandoned,
    required TResult Function() authorized,
    required TResult Function() cancelled,
    required TResult Function() captured,
    required TResult Function() verified,
    required TResult Function() declined,
    required TResult Function() failed,
    required TResult Function() paid,
    required TResult Function() pending,
    required TResult Function() restricted,
    required TResult Function() timeout,
    required TResult Function() unknown,
    required TResult Function() voidStatus,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Abandoned value) abandoned,
    required TResult Function(Authorized value) authorized,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Captured value) captured,
    required TResult Function(Verified value) verified,
    required TResult Function(Declined value) declined,
    required TResult Function(Failed value) failed,
    required TResult Function(Paid value) paid,
    required TResult Function(Pending value) pending,
    required TResult Function(Restricted value) restricted,
    required TResult Function(PaymentTimeout value) timeout,
    required TResult Function(PaymentUnknown value) unknown,
    required TResult Function(VoidPayment value) voidStatus,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PaymentStatusCopyWith<$Res> {
  factory $PaymentStatusCopyWith(
          PaymentStatus value, $Res Function(PaymentStatus) then) =
      _$PaymentStatusCopyWithImpl<$Res>;
}

/// @nodoc
class _$PaymentStatusCopyWithImpl<$Res>
    implements $PaymentStatusCopyWith<$Res> {
  _$PaymentStatusCopyWithImpl(this._value, this._then);

  final PaymentStatus _value;
  // ignore: unused_field
  final $Res Function(PaymentStatus) _then;
}

/// @nodoc
abstract class $AbandonedCopyWith<$Res> {
  factory $AbandonedCopyWith(Abandoned value, $Res Function(Abandoned) then) =
      _$AbandonedCopyWithImpl<$Res>;
}

/// @nodoc
class _$AbandonedCopyWithImpl<$Res> extends _$PaymentStatusCopyWithImpl<$Res>
    implements $AbandonedCopyWith<$Res> {
  _$AbandonedCopyWithImpl(Abandoned _value, $Res Function(Abandoned) _then)
      : super(_value, (v) => _then(v as Abandoned));

  @override
  Abandoned get _value => super._value as Abandoned;
}

/// @nodoc

class _$Abandoned extends Abandoned {
  const _$Abandoned() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Abandoned);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() abandoned,
    required TResult Function() authorized,
    required TResult Function() cancelled,
    required TResult Function() captured,
    required TResult Function() verified,
    required TResult Function() declined,
    required TResult Function() failed,
    required TResult Function() paid,
    required TResult Function() pending,
    required TResult Function() restricted,
    required TResult Function() timeout,
    required TResult Function() unknown,
    required TResult Function() voidStatus,
  }) {
    return abandoned();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
  }) {
    return abandoned?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
    required TResult orElse(),
  }) {
    if (abandoned != null) {
      return abandoned();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Abandoned value) abandoned,
    required TResult Function(Authorized value) authorized,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Captured value) captured,
    required TResult Function(Verified value) verified,
    required TResult Function(Declined value) declined,
    required TResult Function(Failed value) failed,
    required TResult Function(Paid value) paid,
    required TResult Function(Pending value) pending,
    required TResult Function(Restricted value) restricted,
    required TResult Function(PaymentTimeout value) timeout,
    required TResult Function(PaymentUnknown value) unknown,
    required TResult Function(VoidPayment value) voidStatus,
  }) {
    return abandoned(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
  }) {
    return abandoned?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
    required TResult orElse(),
  }) {
    if (abandoned != null) {
      return abandoned(this);
    }
    return orElse();
  }
}

abstract class Abandoned extends PaymentStatus {
  const factory Abandoned() = _$Abandoned;
  const Abandoned._() : super._();
}

/// @nodoc
abstract class $AuthorizedCopyWith<$Res> {
  factory $AuthorizedCopyWith(
          Authorized value, $Res Function(Authorized) then) =
      _$AuthorizedCopyWithImpl<$Res>;
}

/// @nodoc
class _$AuthorizedCopyWithImpl<$Res> extends _$PaymentStatusCopyWithImpl<$Res>
    implements $AuthorizedCopyWith<$Res> {
  _$AuthorizedCopyWithImpl(Authorized _value, $Res Function(Authorized) _then)
      : super(_value, (v) => _then(v as Authorized));

  @override
  Authorized get _value => super._value as Authorized;
}

/// @nodoc

class _$Authorized extends Authorized {
  const _$Authorized() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Authorized);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() abandoned,
    required TResult Function() authorized,
    required TResult Function() cancelled,
    required TResult Function() captured,
    required TResult Function() verified,
    required TResult Function() declined,
    required TResult Function() failed,
    required TResult Function() paid,
    required TResult Function() pending,
    required TResult Function() restricted,
    required TResult Function() timeout,
    required TResult Function() unknown,
    required TResult Function() voidStatus,
  }) {
    return authorized();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
  }) {
    return authorized?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
    required TResult orElse(),
  }) {
    if (authorized != null) {
      return authorized();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Abandoned value) abandoned,
    required TResult Function(Authorized value) authorized,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Captured value) captured,
    required TResult Function(Verified value) verified,
    required TResult Function(Declined value) declined,
    required TResult Function(Failed value) failed,
    required TResult Function(Paid value) paid,
    required TResult Function(Pending value) pending,
    required TResult Function(Restricted value) restricted,
    required TResult Function(PaymentTimeout value) timeout,
    required TResult Function(PaymentUnknown value) unknown,
    required TResult Function(VoidPayment value) voidStatus,
  }) {
    return authorized(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
  }) {
    return authorized?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
    required TResult orElse(),
  }) {
    if (authorized != null) {
      return authorized(this);
    }
    return orElse();
  }
}

abstract class Authorized extends PaymentStatus {
  const factory Authorized() = _$Authorized;
  const Authorized._() : super._();
}

/// @nodoc
abstract class $CancelledCopyWith<$Res> {
  factory $CancelledCopyWith(Cancelled value, $Res Function(Cancelled) then) =
      _$CancelledCopyWithImpl<$Res>;
}

/// @nodoc
class _$CancelledCopyWithImpl<$Res> extends _$PaymentStatusCopyWithImpl<$Res>
    implements $CancelledCopyWith<$Res> {
  _$CancelledCopyWithImpl(Cancelled _value, $Res Function(Cancelled) _then)
      : super(_value, (v) => _then(v as Cancelled));

  @override
  Cancelled get _value => super._value as Cancelled;
}

/// @nodoc

class _$Cancelled extends Cancelled {
  const _$Cancelled() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Cancelled);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() abandoned,
    required TResult Function() authorized,
    required TResult Function() cancelled,
    required TResult Function() captured,
    required TResult Function() verified,
    required TResult Function() declined,
    required TResult Function() failed,
    required TResult Function() paid,
    required TResult Function() pending,
    required TResult Function() restricted,
    required TResult Function() timeout,
    required TResult Function() unknown,
    required TResult Function() voidStatus,
  }) {
    return cancelled();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
  }) {
    return cancelled?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
    required TResult orElse(),
  }) {
    if (cancelled != null) {
      return cancelled();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Abandoned value) abandoned,
    required TResult Function(Authorized value) authorized,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Captured value) captured,
    required TResult Function(Verified value) verified,
    required TResult Function(Declined value) declined,
    required TResult Function(Failed value) failed,
    required TResult Function(Paid value) paid,
    required TResult Function(Pending value) pending,
    required TResult Function(Restricted value) restricted,
    required TResult Function(PaymentTimeout value) timeout,
    required TResult Function(PaymentUnknown value) unknown,
    required TResult Function(VoidPayment value) voidStatus,
  }) {
    return cancelled(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
  }) {
    return cancelled?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
    required TResult orElse(),
  }) {
    if (cancelled != null) {
      return cancelled(this);
    }
    return orElse();
  }
}

abstract class Cancelled extends PaymentStatus {
  const factory Cancelled() = _$Cancelled;
  const Cancelled._() : super._();
}

/// @nodoc
abstract class $CapturedCopyWith<$Res> {
  factory $CapturedCopyWith(Captured value, $Res Function(Captured) then) =
      _$CapturedCopyWithImpl<$Res>;
}

/// @nodoc
class _$CapturedCopyWithImpl<$Res> extends _$PaymentStatusCopyWithImpl<$Res>
    implements $CapturedCopyWith<$Res> {
  _$CapturedCopyWithImpl(Captured _value, $Res Function(Captured) _then)
      : super(_value, (v) => _then(v as Captured));

  @override
  Captured get _value => super._value as Captured;
}

/// @nodoc

class _$Captured extends Captured {
  const _$Captured() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Captured);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() abandoned,
    required TResult Function() authorized,
    required TResult Function() cancelled,
    required TResult Function() captured,
    required TResult Function() verified,
    required TResult Function() declined,
    required TResult Function() failed,
    required TResult Function() paid,
    required TResult Function() pending,
    required TResult Function() restricted,
    required TResult Function() timeout,
    required TResult Function() unknown,
    required TResult Function() voidStatus,
  }) {
    return captured();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
  }) {
    return captured?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
    required TResult orElse(),
  }) {
    if (captured != null) {
      return captured();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Abandoned value) abandoned,
    required TResult Function(Authorized value) authorized,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Captured value) captured,
    required TResult Function(Verified value) verified,
    required TResult Function(Declined value) declined,
    required TResult Function(Failed value) failed,
    required TResult Function(Paid value) paid,
    required TResult Function(Pending value) pending,
    required TResult Function(Restricted value) restricted,
    required TResult Function(PaymentTimeout value) timeout,
    required TResult Function(PaymentUnknown value) unknown,
    required TResult Function(VoidPayment value) voidStatus,
  }) {
    return captured(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
  }) {
    return captured?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
    required TResult orElse(),
  }) {
    if (captured != null) {
      return captured(this);
    }
    return orElse();
  }
}

abstract class Captured extends PaymentStatus {
  const factory Captured() = _$Captured;
  const Captured._() : super._();
}

/// @nodoc
abstract class $VerifiedCopyWith<$Res> {
  factory $VerifiedCopyWith(Verified value, $Res Function(Verified) then) =
      _$VerifiedCopyWithImpl<$Res>;
}

/// @nodoc
class _$VerifiedCopyWithImpl<$Res> extends _$PaymentStatusCopyWithImpl<$Res>
    implements $VerifiedCopyWith<$Res> {
  _$VerifiedCopyWithImpl(Verified _value, $Res Function(Verified) _then)
      : super(_value, (v) => _then(v as Verified));

  @override
  Verified get _value => super._value as Verified;
}

/// @nodoc

class _$Verified extends Verified {
  const _$Verified() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Verified);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() abandoned,
    required TResult Function() authorized,
    required TResult Function() cancelled,
    required TResult Function() captured,
    required TResult Function() verified,
    required TResult Function() declined,
    required TResult Function() failed,
    required TResult Function() paid,
    required TResult Function() pending,
    required TResult Function() restricted,
    required TResult Function() timeout,
    required TResult Function() unknown,
    required TResult Function() voidStatus,
  }) {
    return verified();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
  }) {
    return verified?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
    required TResult orElse(),
  }) {
    if (verified != null) {
      return verified();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Abandoned value) abandoned,
    required TResult Function(Authorized value) authorized,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Captured value) captured,
    required TResult Function(Verified value) verified,
    required TResult Function(Declined value) declined,
    required TResult Function(Failed value) failed,
    required TResult Function(Paid value) paid,
    required TResult Function(Pending value) pending,
    required TResult Function(Restricted value) restricted,
    required TResult Function(PaymentTimeout value) timeout,
    required TResult Function(PaymentUnknown value) unknown,
    required TResult Function(VoidPayment value) voidStatus,
  }) {
    return verified(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
  }) {
    return verified?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
    required TResult orElse(),
  }) {
    if (verified != null) {
      return verified(this);
    }
    return orElse();
  }
}

abstract class Verified extends PaymentStatus {
  const factory Verified() = _$Verified;
  const Verified._() : super._();
}

/// @nodoc
abstract class $DeclinedCopyWith<$Res> {
  factory $DeclinedCopyWith(Declined value, $Res Function(Declined) then) =
      _$DeclinedCopyWithImpl<$Res>;
}

/// @nodoc
class _$DeclinedCopyWithImpl<$Res> extends _$PaymentStatusCopyWithImpl<$Res>
    implements $DeclinedCopyWith<$Res> {
  _$DeclinedCopyWithImpl(Declined _value, $Res Function(Declined) _then)
      : super(_value, (v) => _then(v as Declined));

  @override
  Declined get _value => super._value as Declined;
}

/// @nodoc

class _$Declined extends Declined {
  const _$Declined() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Declined);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() abandoned,
    required TResult Function() authorized,
    required TResult Function() cancelled,
    required TResult Function() captured,
    required TResult Function() verified,
    required TResult Function() declined,
    required TResult Function() failed,
    required TResult Function() paid,
    required TResult Function() pending,
    required TResult Function() restricted,
    required TResult Function() timeout,
    required TResult Function() unknown,
    required TResult Function() voidStatus,
  }) {
    return declined();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
  }) {
    return declined?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
    required TResult orElse(),
  }) {
    if (declined != null) {
      return declined();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Abandoned value) abandoned,
    required TResult Function(Authorized value) authorized,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Captured value) captured,
    required TResult Function(Verified value) verified,
    required TResult Function(Declined value) declined,
    required TResult Function(Failed value) failed,
    required TResult Function(Paid value) paid,
    required TResult Function(Pending value) pending,
    required TResult Function(Restricted value) restricted,
    required TResult Function(PaymentTimeout value) timeout,
    required TResult Function(PaymentUnknown value) unknown,
    required TResult Function(VoidPayment value) voidStatus,
  }) {
    return declined(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
  }) {
    return declined?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
    required TResult orElse(),
  }) {
    if (declined != null) {
      return declined(this);
    }
    return orElse();
  }
}

abstract class Declined extends PaymentStatus {
  const factory Declined() = _$Declined;
  const Declined._() : super._();
}

/// @nodoc
abstract class $FailedCopyWith<$Res> {
  factory $FailedCopyWith(Failed value, $Res Function(Failed) then) =
      _$FailedCopyWithImpl<$Res>;
}

/// @nodoc
class _$FailedCopyWithImpl<$Res> extends _$PaymentStatusCopyWithImpl<$Res>
    implements $FailedCopyWith<$Res> {
  _$FailedCopyWithImpl(Failed _value, $Res Function(Failed) _then)
      : super(_value, (v) => _then(v as Failed));

  @override
  Failed get _value => super._value as Failed;
}

/// @nodoc

class _$Failed extends Failed {
  const _$Failed() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Failed);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() abandoned,
    required TResult Function() authorized,
    required TResult Function() cancelled,
    required TResult Function() captured,
    required TResult Function() verified,
    required TResult Function() declined,
    required TResult Function() failed,
    required TResult Function() paid,
    required TResult Function() pending,
    required TResult Function() restricted,
    required TResult Function() timeout,
    required TResult Function() unknown,
    required TResult Function() voidStatus,
  }) {
    return failed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
  }) {
    return failed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
    required TResult orElse(),
  }) {
    if (failed != null) {
      return failed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Abandoned value) abandoned,
    required TResult Function(Authorized value) authorized,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Captured value) captured,
    required TResult Function(Verified value) verified,
    required TResult Function(Declined value) declined,
    required TResult Function(Failed value) failed,
    required TResult Function(Paid value) paid,
    required TResult Function(Pending value) pending,
    required TResult Function(Restricted value) restricted,
    required TResult Function(PaymentTimeout value) timeout,
    required TResult Function(PaymentUnknown value) unknown,
    required TResult Function(VoidPayment value) voidStatus,
  }) {
    return failed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
  }) {
    return failed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
    required TResult orElse(),
  }) {
    if (failed != null) {
      return failed(this);
    }
    return orElse();
  }
}

abstract class Failed extends PaymentStatus {
  const factory Failed() = _$Failed;
  const Failed._() : super._();
}

/// @nodoc
abstract class $PaidCopyWith<$Res> {
  factory $PaidCopyWith(Paid value, $Res Function(Paid) then) =
      _$PaidCopyWithImpl<$Res>;
}

/// @nodoc
class _$PaidCopyWithImpl<$Res> extends _$PaymentStatusCopyWithImpl<$Res>
    implements $PaidCopyWith<$Res> {
  _$PaidCopyWithImpl(Paid _value, $Res Function(Paid) _then)
      : super(_value, (v) => _then(v as Paid));

  @override
  Paid get _value => super._value as Paid;
}

/// @nodoc

class _$Paid extends Paid {
  const _$Paid() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Paid);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() abandoned,
    required TResult Function() authorized,
    required TResult Function() cancelled,
    required TResult Function() captured,
    required TResult Function() verified,
    required TResult Function() declined,
    required TResult Function() failed,
    required TResult Function() paid,
    required TResult Function() pending,
    required TResult Function() restricted,
    required TResult Function() timeout,
    required TResult Function() unknown,
    required TResult Function() voidStatus,
  }) {
    return paid();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
  }) {
    return paid?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
    required TResult orElse(),
  }) {
    if (paid != null) {
      return paid();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Abandoned value) abandoned,
    required TResult Function(Authorized value) authorized,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Captured value) captured,
    required TResult Function(Verified value) verified,
    required TResult Function(Declined value) declined,
    required TResult Function(Failed value) failed,
    required TResult Function(Paid value) paid,
    required TResult Function(Pending value) pending,
    required TResult Function(Restricted value) restricted,
    required TResult Function(PaymentTimeout value) timeout,
    required TResult Function(PaymentUnknown value) unknown,
    required TResult Function(VoidPayment value) voidStatus,
  }) {
    return paid(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
  }) {
    return paid?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
    required TResult orElse(),
  }) {
    if (paid != null) {
      return paid(this);
    }
    return orElse();
  }
}

abstract class Paid extends PaymentStatus {
  const factory Paid() = _$Paid;
  const Paid._() : super._();
}

/// @nodoc
abstract class $PendingCopyWith<$Res> {
  factory $PendingCopyWith(Pending value, $Res Function(Pending) then) =
      _$PendingCopyWithImpl<$Res>;
}

/// @nodoc
class _$PendingCopyWithImpl<$Res> extends _$PaymentStatusCopyWithImpl<$Res>
    implements $PendingCopyWith<$Res> {
  _$PendingCopyWithImpl(Pending _value, $Res Function(Pending) _then)
      : super(_value, (v) => _then(v as Pending));

  @override
  Pending get _value => super._value as Pending;
}

/// @nodoc

class _$Pending extends Pending {
  const _$Pending() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Pending);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() abandoned,
    required TResult Function() authorized,
    required TResult Function() cancelled,
    required TResult Function() captured,
    required TResult Function() verified,
    required TResult Function() declined,
    required TResult Function() failed,
    required TResult Function() paid,
    required TResult Function() pending,
    required TResult Function() restricted,
    required TResult Function() timeout,
    required TResult Function() unknown,
    required TResult Function() voidStatus,
  }) {
    return pending();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
  }) {
    return pending?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
    required TResult orElse(),
  }) {
    if (pending != null) {
      return pending();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Abandoned value) abandoned,
    required TResult Function(Authorized value) authorized,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Captured value) captured,
    required TResult Function(Verified value) verified,
    required TResult Function(Declined value) declined,
    required TResult Function(Failed value) failed,
    required TResult Function(Paid value) paid,
    required TResult Function(Pending value) pending,
    required TResult Function(Restricted value) restricted,
    required TResult Function(PaymentTimeout value) timeout,
    required TResult Function(PaymentUnknown value) unknown,
    required TResult Function(VoidPayment value) voidStatus,
  }) {
    return pending(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
  }) {
    return pending?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
    required TResult orElse(),
  }) {
    if (pending != null) {
      return pending(this);
    }
    return orElse();
  }
}

abstract class Pending extends PaymentStatus {
  const factory Pending() = _$Pending;
  const Pending._() : super._();
}

/// @nodoc
abstract class $RestrictedCopyWith<$Res> {
  factory $RestrictedCopyWith(
          Restricted value, $Res Function(Restricted) then) =
      _$RestrictedCopyWithImpl<$Res>;
}

/// @nodoc
class _$RestrictedCopyWithImpl<$Res> extends _$PaymentStatusCopyWithImpl<$Res>
    implements $RestrictedCopyWith<$Res> {
  _$RestrictedCopyWithImpl(Restricted _value, $Res Function(Restricted) _then)
      : super(_value, (v) => _then(v as Restricted));

  @override
  Restricted get _value => super._value as Restricted;
}

/// @nodoc

class _$Restricted extends Restricted {
  const _$Restricted() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Restricted);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() abandoned,
    required TResult Function() authorized,
    required TResult Function() cancelled,
    required TResult Function() captured,
    required TResult Function() verified,
    required TResult Function() declined,
    required TResult Function() failed,
    required TResult Function() paid,
    required TResult Function() pending,
    required TResult Function() restricted,
    required TResult Function() timeout,
    required TResult Function() unknown,
    required TResult Function() voidStatus,
  }) {
    return restricted();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
  }) {
    return restricted?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
    required TResult orElse(),
  }) {
    if (restricted != null) {
      return restricted();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Abandoned value) abandoned,
    required TResult Function(Authorized value) authorized,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Captured value) captured,
    required TResult Function(Verified value) verified,
    required TResult Function(Declined value) declined,
    required TResult Function(Failed value) failed,
    required TResult Function(Paid value) paid,
    required TResult Function(Pending value) pending,
    required TResult Function(Restricted value) restricted,
    required TResult Function(PaymentTimeout value) timeout,
    required TResult Function(PaymentUnknown value) unknown,
    required TResult Function(VoidPayment value) voidStatus,
  }) {
    return restricted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
  }) {
    return restricted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
    required TResult orElse(),
  }) {
    if (restricted != null) {
      return restricted(this);
    }
    return orElse();
  }
}

abstract class Restricted extends PaymentStatus {
  const factory Restricted() = _$Restricted;
  const Restricted._() : super._();
}

/// @nodoc
abstract class $PaymentTimeoutCopyWith<$Res> {
  factory $PaymentTimeoutCopyWith(
          PaymentTimeout value, $Res Function(PaymentTimeout) then) =
      _$PaymentTimeoutCopyWithImpl<$Res>;
}

/// @nodoc
class _$PaymentTimeoutCopyWithImpl<$Res>
    extends _$PaymentStatusCopyWithImpl<$Res>
    implements $PaymentTimeoutCopyWith<$Res> {
  _$PaymentTimeoutCopyWithImpl(
      PaymentTimeout _value, $Res Function(PaymentTimeout) _then)
      : super(_value, (v) => _then(v as PaymentTimeout));

  @override
  PaymentTimeout get _value => super._value as PaymentTimeout;
}

/// @nodoc

class _$PaymentTimeout extends PaymentTimeout {
  const _$PaymentTimeout() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is PaymentTimeout);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() abandoned,
    required TResult Function() authorized,
    required TResult Function() cancelled,
    required TResult Function() captured,
    required TResult Function() verified,
    required TResult Function() declined,
    required TResult Function() failed,
    required TResult Function() paid,
    required TResult Function() pending,
    required TResult Function() restricted,
    required TResult Function() timeout,
    required TResult Function() unknown,
    required TResult Function() voidStatus,
  }) {
    return timeout();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
  }) {
    return timeout?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
    required TResult orElse(),
  }) {
    if (timeout != null) {
      return timeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Abandoned value) abandoned,
    required TResult Function(Authorized value) authorized,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Captured value) captured,
    required TResult Function(Verified value) verified,
    required TResult Function(Declined value) declined,
    required TResult Function(Failed value) failed,
    required TResult Function(Paid value) paid,
    required TResult Function(Pending value) pending,
    required TResult Function(Restricted value) restricted,
    required TResult Function(PaymentTimeout value) timeout,
    required TResult Function(PaymentUnknown value) unknown,
    required TResult Function(VoidPayment value) voidStatus,
  }) {
    return timeout(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
  }) {
    return timeout?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
    required TResult orElse(),
  }) {
    if (timeout != null) {
      return timeout(this);
    }
    return orElse();
  }
}

abstract class PaymentTimeout extends PaymentStatus {
  const factory PaymentTimeout() = _$PaymentTimeout;
  const PaymentTimeout._() : super._();
}

/// @nodoc
abstract class $PaymentUnknownCopyWith<$Res> {
  factory $PaymentUnknownCopyWith(
          PaymentUnknown value, $Res Function(PaymentUnknown) then) =
      _$PaymentUnknownCopyWithImpl<$Res>;
}

/// @nodoc
class _$PaymentUnknownCopyWithImpl<$Res>
    extends _$PaymentStatusCopyWithImpl<$Res>
    implements $PaymentUnknownCopyWith<$Res> {
  _$PaymentUnknownCopyWithImpl(
      PaymentUnknown _value, $Res Function(PaymentUnknown) _then)
      : super(_value, (v) => _then(v as PaymentUnknown));

  @override
  PaymentUnknown get _value => super._value as PaymentUnknown;
}

/// @nodoc

class _$PaymentUnknown extends PaymentUnknown {
  const _$PaymentUnknown() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is PaymentUnknown);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() abandoned,
    required TResult Function() authorized,
    required TResult Function() cancelled,
    required TResult Function() captured,
    required TResult Function() verified,
    required TResult Function() declined,
    required TResult Function() failed,
    required TResult Function() paid,
    required TResult Function() pending,
    required TResult Function() restricted,
    required TResult Function() timeout,
    required TResult Function() unknown,
    required TResult Function() voidStatus,
  }) {
    return unknown();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
  }) {
    return unknown?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Abandoned value) abandoned,
    required TResult Function(Authorized value) authorized,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Captured value) captured,
    required TResult Function(Verified value) verified,
    required TResult Function(Declined value) declined,
    required TResult Function(Failed value) failed,
    required TResult Function(Paid value) paid,
    required TResult Function(Pending value) pending,
    required TResult Function(Restricted value) restricted,
    required TResult Function(PaymentTimeout value) timeout,
    required TResult Function(PaymentUnknown value) unknown,
    required TResult Function(VoidPayment value) voidStatus,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class PaymentUnknown extends PaymentStatus {
  const factory PaymentUnknown() = _$PaymentUnknown;
  const PaymentUnknown._() : super._();
}

/// @nodoc
abstract class $VoidPaymentCopyWith<$Res> {
  factory $VoidPaymentCopyWith(
          VoidPayment value, $Res Function(VoidPayment) then) =
      _$VoidPaymentCopyWithImpl<$Res>;
}

/// @nodoc
class _$VoidPaymentCopyWithImpl<$Res> extends _$PaymentStatusCopyWithImpl<$Res>
    implements $VoidPaymentCopyWith<$Res> {
  _$VoidPaymentCopyWithImpl(
      VoidPayment _value, $Res Function(VoidPayment) _then)
      : super(_value, (v) => _then(v as VoidPayment));

  @override
  VoidPayment get _value => super._value as VoidPayment;
}

/// @nodoc

class _$VoidPayment extends VoidPayment {
  const _$VoidPayment() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is VoidPayment);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() abandoned,
    required TResult Function() authorized,
    required TResult Function() cancelled,
    required TResult Function() captured,
    required TResult Function() verified,
    required TResult Function() declined,
    required TResult Function() failed,
    required TResult Function() paid,
    required TResult Function() pending,
    required TResult Function() restricted,
    required TResult Function() timeout,
    required TResult Function() unknown,
    required TResult Function() voidStatus,
  }) {
    return voidStatus();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
  }) {
    return voidStatus?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? abandoned,
    TResult Function()? authorized,
    TResult Function()? cancelled,
    TResult Function()? captured,
    TResult Function()? verified,
    TResult Function()? declined,
    TResult Function()? failed,
    TResult Function()? paid,
    TResult Function()? pending,
    TResult Function()? restricted,
    TResult Function()? timeout,
    TResult Function()? unknown,
    TResult Function()? voidStatus,
    required TResult orElse(),
  }) {
    if (voidStatus != null) {
      return voidStatus();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Abandoned value) abandoned,
    required TResult Function(Authorized value) authorized,
    required TResult Function(Cancelled value) cancelled,
    required TResult Function(Captured value) captured,
    required TResult Function(Verified value) verified,
    required TResult Function(Declined value) declined,
    required TResult Function(Failed value) failed,
    required TResult Function(Paid value) paid,
    required TResult Function(Pending value) pending,
    required TResult Function(Restricted value) restricted,
    required TResult Function(PaymentTimeout value) timeout,
    required TResult Function(PaymentUnknown value) unknown,
    required TResult Function(VoidPayment value) voidStatus,
  }) {
    return voidStatus(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
  }) {
    return voidStatus?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Abandoned value)? abandoned,
    TResult Function(Authorized value)? authorized,
    TResult Function(Cancelled value)? cancelled,
    TResult Function(Captured value)? captured,
    TResult Function(Verified value)? verified,
    TResult Function(Declined value)? declined,
    TResult Function(Failed value)? failed,
    TResult Function(Paid value)? paid,
    TResult Function(Pending value)? pending,
    TResult Function(Restricted value)? restricted,
    TResult Function(PaymentTimeout value)? timeout,
    TResult Function(PaymentUnknown value)? unknown,
    TResult Function(VoidPayment value)? voidStatus,
    required TResult orElse(),
  }) {
    if (voidStatus != null) {
      return voidStatus(this);
    }
    return orElse();
  }
}

abstract class VoidPayment extends PaymentStatus {
  const factory VoidPayment() = _$VoidPayment;
  const VoidPayment._() : super._();
}
