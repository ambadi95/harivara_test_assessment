// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'passcode_attempt_type.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$PasscodeAttemptTypeTearOff {
  const _$PasscodeAttemptTypeTearOff();

  InitialAttempt initialAttempt() {
    return const InitialAttempt();
  }

  FirstAttempt firstAttempt() {
    return const FirstAttempt();
  }

  SecondAttempt secondAttempt() {
    return const SecondAttempt();
  }

  ThirdAttempt thirdAttempt() {
    return const ThirdAttempt();
  }
}

/// @nodoc
const $PasscodeAttemptType = _$PasscodeAttemptTypeTearOff();

/// @nodoc
mixin _$PasscodeAttemptType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialAttempt,
    required TResult Function() firstAttempt,
    required TResult Function() secondAttempt,
    required TResult Function() thirdAttempt,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialAttempt,
    TResult Function()? firstAttempt,
    TResult Function()? secondAttempt,
    TResult Function()? thirdAttempt,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialAttempt,
    TResult Function()? firstAttempt,
    TResult Function()? secondAttempt,
    TResult Function()? thirdAttempt,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialAttempt value) initialAttempt,
    required TResult Function(FirstAttempt value) firstAttempt,
    required TResult Function(SecondAttempt value) secondAttempt,
    required TResult Function(ThirdAttempt value) thirdAttempt,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InitialAttempt value)? initialAttempt,
    TResult Function(FirstAttempt value)? firstAttempt,
    TResult Function(SecondAttempt value)? secondAttempt,
    TResult Function(ThirdAttempt value)? thirdAttempt,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialAttempt value)? initialAttempt,
    TResult Function(FirstAttempt value)? firstAttempt,
    TResult Function(SecondAttempt value)? secondAttempt,
    TResult Function(ThirdAttempt value)? thirdAttempt,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PasscodeAttemptTypeCopyWith<$Res> {
  factory $PasscodeAttemptTypeCopyWith(
          PasscodeAttemptType value, $Res Function(PasscodeAttemptType) then) =
      _$PasscodeAttemptTypeCopyWithImpl<$Res>;
}

/// @nodoc
class _$PasscodeAttemptTypeCopyWithImpl<$Res>
    implements $PasscodeAttemptTypeCopyWith<$Res> {
  _$PasscodeAttemptTypeCopyWithImpl(this._value, this._then);

  final PasscodeAttemptType _value;
  // ignore: unused_field
  final $Res Function(PasscodeAttemptType) _then;
}

/// @nodoc
abstract class $InitialAttemptCopyWith<$Res> {
  factory $InitialAttemptCopyWith(
          InitialAttempt value, $Res Function(InitialAttempt) then) =
      _$InitialAttemptCopyWithImpl<$Res>;
}

/// @nodoc
class _$InitialAttemptCopyWithImpl<$Res>
    extends _$PasscodeAttemptTypeCopyWithImpl<$Res>
    implements $InitialAttemptCopyWith<$Res> {
  _$InitialAttemptCopyWithImpl(
      InitialAttempt _value, $Res Function(InitialAttempt) _then)
      : super(_value, (v) => _then(v as InitialAttempt));

  @override
  InitialAttempt get _value => super._value as InitialAttempt;
}

/// @nodoc

class _$InitialAttempt extends InitialAttempt {
  const _$InitialAttempt() : super._();

  @override
  String toString() {
    return 'PasscodeAttemptType.initialAttempt()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is InitialAttempt);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialAttempt,
    required TResult Function() firstAttempt,
    required TResult Function() secondAttempt,
    required TResult Function() thirdAttempt,
  }) {
    return initialAttempt();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialAttempt,
    TResult Function()? firstAttempt,
    TResult Function()? secondAttempt,
    TResult Function()? thirdAttempt,
  }) {
    return initialAttempt?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialAttempt,
    TResult Function()? firstAttempt,
    TResult Function()? secondAttempt,
    TResult Function()? thirdAttempt,
    required TResult orElse(),
  }) {
    if (initialAttempt != null) {
      return initialAttempt();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialAttempt value) initialAttempt,
    required TResult Function(FirstAttempt value) firstAttempt,
    required TResult Function(SecondAttempt value) secondAttempt,
    required TResult Function(ThirdAttempt value) thirdAttempt,
  }) {
    return initialAttempt(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InitialAttempt value)? initialAttempt,
    TResult Function(FirstAttempt value)? firstAttempt,
    TResult Function(SecondAttempt value)? secondAttempt,
    TResult Function(ThirdAttempt value)? thirdAttempt,
  }) {
    return initialAttempt?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialAttempt value)? initialAttempt,
    TResult Function(FirstAttempt value)? firstAttempt,
    TResult Function(SecondAttempt value)? secondAttempt,
    TResult Function(ThirdAttempt value)? thirdAttempt,
    required TResult orElse(),
  }) {
    if (initialAttempt != null) {
      return initialAttempt(this);
    }
    return orElse();
  }
}

abstract class InitialAttempt extends PasscodeAttemptType {
  const factory InitialAttempt() = _$InitialAttempt;
  const InitialAttempt._() : super._();
}

/// @nodoc
abstract class $FirstAttemptCopyWith<$Res> {
  factory $FirstAttemptCopyWith(
          FirstAttempt value, $Res Function(FirstAttempt) then) =
      _$FirstAttemptCopyWithImpl<$Res>;
}

/// @nodoc
class _$FirstAttemptCopyWithImpl<$Res>
    extends _$PasscodeAttemptTypeCopyWithImpl<$Res>
    implements $FirstAttemptCopyWith<$Res> {
  _$FirstAttemptCopyWithImpl(
      FirstAttempt _value, $Res Function(FirstAttempt) _then)
      : super(_value, (v) => _then(v as FirstAttempt));

  @override
  FirstAttempt get _value => super._value as FirstAttempt;
}

/// @nodoc

class _$FirstAttempt extends FirstAttempt {
  const _$FirstAttempt() : super._();

  @override
  String toString() {
    return 'PasscodeAttemptType.firstAttempt()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is FirstAttempt);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialAttempt,
    required TResult Function() firstAttempt,
    required TResult Function() secondAttempt,
    required TResult Function() thirdAttempt,
  }) {
    return firstAttempt();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialAttempt,
    TResult Function()? firstAttempt,
    TResult Function()? secondAttempt,
    TResult Function()? thirdAttempt,
  }) {
    return firstAttempt?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialAttempt,
    TResult Function()? firstAttempt,
    TResult Function()? secondAttempt,
    TResult Function()? thirdAttempt,
    required TResult orElse(),
  }) {
    if (firstAttempt != null) {
      return firstAttempt();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialAttempt value) initialAttempt,
    required TResult Function(FirstAttempt value) firstAttempt,
    required TResult Function(SecondAttempt value) secondAttempt,
    required TResult Function(ThirdAttempt value) thirdAttempt,
  }) {
    return firstAttempt(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InitialAttempt value)? initialAttempt,
    TResult Function(FirstAttempt value)? firstAttempt,
    TResult Function(SecondAttempt value)? secondAttempt,
    TResult Function(ThirdAttempt value)? thirdAttempt,
  }) {
    return firstAttempt?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialAttempt value)? initialAttempt,
    TResult Function(FirstAttempt value)? firstAttempt,
    TResult Function(SecondAttempt value)? secondAttempt,
    TResult Function(ThirdAttempt value)? thirdAttempt,
    required TResult orElse(),
  }) {
    if (firstAttempt != null) {
      return firstAttempt(this);
    }
    return orElse();
  }
}

abstract class FirstAttempt extends PasscodeAttemptType {
  const factory FirstAttempt() = _$FirstAttempt;
  const FirstAttempt._() : super._();
}

/// @nodoc
abstract class $SecondAttemptCopyWith<$Res> {
  factory $SecondAttemptCopyWith(
          SecondAttempt value, $Res Function(SecondAttempt) then) =
      _$SecondAttemptCopyWithImpl<$Res>;
}

/// @nodoc
class _$SecondAttemptCopyWithImpl<$Res>
    extends _$PasscodeAttemptTypeCopyWithImpl<$Res>
    implements $SecondAttemptCopyWith<$Res> {
  _$SecondAttemptCopyWithImpl(
      SecondAttempt _value, $Res Function(SecondAttempt) _then)
      : super(_value, (v) => _then(v as SecondAttempt));

  @override
  SecondAttempt get _value => super._value as SecondAttempt;
}

/// @nodoc

class _$SecondAttempt extends SecondAttempt {
  const _$SecondAttempt() : super._();

  @override
  String toString() {
    return 'PasscodeAttemptType.secondAttempt()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is SecondAttempt);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialAttempt,
    required TResult Function() firstAttempt,
    required TResult Function() secondAttempt,
    required TResult Function() thirdAttempt,
  }) {
    return secondAttempt();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialAttempt,
    TResult Function()? firstAttempt,
    TResult Function()? secondAttempt,
    TResult Function()? thirdAttempt,
  }) {
    return secondAttempt?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialAttempt,
    TResult Function()? firstAttempt,
    TResult Function()? secondAttempt,
    TResult Function()? thirdAttempt,
    required TResult orElse(),
  }) {
    if (secondAttempt != null) {
      return secondAttempt();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialAttempt value) initialAttempt,
    required TResult Function(FirstAttempt value) firstAttempt,
    required TResult Function(SecondAttempt value) secondAttempt,
    required TResult Function(ThirdAttempt value) thirdAttempt,
  }) {
    return secondAttempt(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InitialAttempt value)? initialAttempt,
    TResult Function(FirstAttempt value)? firstAttempt,
    TResult Function(SecondAttempt value)? secondAttempt,
    TResult Function(ThirdAttempt value)? thirdAttempt,
  }) {
    return secondAttempt?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialAttempt value)? initialAttempt,
    TResult Function(FirstAttempt value)? firstAttempt,
    TResult Function(SecondAttempt value)? secondAttempt,
    TResult Function(ThirdAttempt value)? thirdAttempt,
    required TResult orElse(),
  }) {
    if (secondAttempt != null) {
      return secondAttempt(this);
    }
    return orElse();
  }
}

abstract class SecondAttempt extends PasscodeAttemptType {
  const factory SecondAttempt() = _$SecondAttempt;
  const SecondAttempt._() : super._();
}

/// @nodoc
abstract class $ThirdAttemptCopyWith<$Res> {
  factory $ThirdAttemptCopyWith(
          ThirdAttempt value, $Res Function(ThirdAttempt) then) =
      _$ThirdAttemptCopyWithImpl<$Res>;
}

/// @nodoc
class _$ThirdAttemptCopyWithImpl<$Res>
    extends _$PasscodeAttemptTypeCopyWithImpl<$Res>
    implements $ThirdAttemptCopyWith<$Res> {
  _$ThirdAttemptCopyWithImpl(
      ThirdAttempt _value, $Res Function(ThirdAttempt) _then)
      : super(_value, (v) => _then(v as ThirdAttempt));

  @override
  ThirdAttempt get _value => super._value as ThirdAttempt;
}

/// @nodoc

class _$ThirdAttempt extends ThirdAttempt {
  const _$ThirdAttempt() : super._();

  @override
  String toString() {
    return 'PasscodeAttemptType.thirdAttempt()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is ThirdAttempt);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialAttempt,
    required TResult Function() firstAttempt,
    required TResult Function() secondAttempt,
    required TResult Function() thirdAttempt,
  }) {
    return thirdAttempt();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialAttempt,
    TResult Function()? firstAttempt,
    TResult Function()? secondAttempt,
    TResult Function()? thirdAttempt,
  }) {
    return thirdAttempt?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialAttempt,
    TResult Function()? firstAttempt,
    TResult Function()? secondAttempt,
    TResult Function()? thirdAttempt,
    required TResult orElse(),
  }) {
    if (thirdAttempt != null) {
      return thirdAttempt();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialAttempt value) initialAttempt,
    required TResult Function(FirstAttempt value) firstAttempt,
    required TResult Function(SecondAttempt value) secondAttempt,
    required TResult Function(ThirdAttempt value) thirdAttempt,
  }) {
    return thirdAttempt(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InitialAttempt value)? initialAttempt,
    TResult Function(FirstAttempt value)? firstAttempt,
    TResult Function(SecondAttempt value)? secondAttempt,
    TResult Function(ThirdAttempt value)? thirdAttempt,
  }) {
    return thirdAttempt?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialAttempt value)? initialAttempt,
    TResult Function(FirstAttempt value)? firstAttempt,
    TResult Function(SecondAttempt value)? secondAttempt,
    TResult Function(ThirdAttempt value)? thirdAttempt,
    required TResult orElse(),
  }) {
    if (thirdAttempt != null) {
      return thirdAttempt(this);
    }
    return orElse();
  }
}

abstract class ThirdAttempt extends PasscodeAttemptType {
  const factory ThirdAttempt() = _$ThirdAttempt;
  const ThirdAttempt._() : super._();
}
