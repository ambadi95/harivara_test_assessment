// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'source_screen.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$SourceScreen {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() customerHome,
    required TResult Function() merchantHome,
    required TResult Function() payment,
    required TResult Function() settings,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? customerHome,
    TResult Function()? merchantHome,
    TResult Function()? payment,
    TResult Function()? settings,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? customerHome,
    TResult Function()? merchantHome,
    TResult Function()? payment,
    TResult Function()? settings,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CustomerHomeScreen value) customerHome,
    required TResult Function(MerchantHomeScreen value) merchantHome,
    required TResult Function(PaymentScreen value) payment,
    required TResult Function(SettingsScreen value) settings,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(CustomerHomeScreen value)? customerHome,
    TResult Function(MerchantHomeScreen value)? merchantHome,
    TResult Function(PaymentScreen value)? payment,
    TResult Function(SettingsScreen value)? settings,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CustomerHomeScreen value)? customerHome,
    TResult Function(MerchantHomeScreen value)? merchantHome,
    TResult Function(PaymentScreen value)? payment,
    TResult Function(SettingsScreen value)? settings,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SourceScreenCopyWith<$Res> {
  factory $SourceScreenCopyWith(
          SourceScreen value, $Res Function(SourceScreen) then) =
      _$SourceScreenCopyWithImpl<$Res>;
}

/// @nodoc
class _$SourceScreenCopyWithImpl<$Res> implements $SourceScreenCopyWith<$Res> {
  _$SourceScreenCopyWithImpl(this._value, this._then);

  final SourceScreen _value;
  // ignore: unused_field
  final $Res Function(SourceScreen) _then;
}

/// @nodoc
abstract class _$$CustomerHomeScreenCopyWith<$Res> {
  factory _$$CustomerHomeScreenCopyWith(_$CustomerHomeScreen value,
          $Res Function(_$CustomerHomeScreen) then) =
      __$$CustomerHomeScreenCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CustomerHomeScreenCopyWithImpl<$Res>
    extends _$SourceScreenCopyWithImpl<$Res>
    implements _$$CustomerHomeScreenCopyWith<$Res> {
  __$$CustomerHomeScreenCopyWithImpl(
      _$CustomerHomeScreen _value, $Res Function(_$CustomerHomeScreen) _then)
      : super(_value, (v) => _then(v as _$CustomerHomeScreen));

  @override
  _$CustomerHomeScreen get _value => super._value as _$CustomerHomeScreen;
}

/// @nodoc

class _$CustomerHomeScreen extends CustomerHomeScreen {
  const _$CustomerHomeScreen() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CustomerHomeScreen);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() customerHome,
    required TResult Function() merchantHome,
    required TResult Function() payment,
    required TResult Function() settings,
  }) {
    return customerHome();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? customerHome,
    TResult Function()? merchantHome,
    TResult Function()? payment,
    TResult Function()? settings,
  }) {
    return customerHome?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? customerHome,
    TResult Function()? merchantHome,
    TResult Function()? payment,
    TResult Function()? settings,
    required TResult orElse(),
  }) {
    if (customerHome != null) {
      return customerHome();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CustomerHomeScreen value) customerHome,
    required TResult Function(MerchantHomeScreen value) merchantHome,
    required TResult Function(PaymentScreen value) payment,
    required TResult Function(SettingsScreen value) settings,
  }) {
    return customerHome(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(CustomerHomeScreen value)? customerHome,
    TResult Function(MerchantHomeScreen value)? merchantHome,
    TResult Function(PaymentScreen value)? payment,
    TResult Function(SettingsScreen value)? settings,
  }) {
    return customerHome?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CustomerHomeScreen value)? customerHome,
    TResult Function(MerchantHomeScreen value)? merchantHome,
    TResult Function(PaymentScreen value)? payment,
    TResult Function(SettingsScreen value)? settings,
    required TResult orElse(),
  }) {
    if (customerHome != null) {
      return customerHome(this);
    }
    return orElse();
  }
}

abstract class CustomerHomeScreen extends SourceScreen {
  const factory CustomerHomeScreen() = _$CustomerHomeScreen;
  const CustomerHomeScreen._() : super._();
}

/// @nodoc
abstract class _$$MerchantHomeScreenCopyWith<$Res> {
  factory _$$MerchantHomeScreenCopyWith(_$MerchantHomeScreen value,
          $Res Function(_$MerchantHomeScreen) then) =
      __$$MerchantHomeScreenCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MerchantHomeScreenCopyWithImpl<$Res>
    extends _$SourceScreenCopyWithImpl<$Res>
    implements _$$MerchantHomeScreenCopyWith<$Res> {
  __$$MerchantHomeScreenCopyWithImpl(
      _$MerchantHomeScreen _value, $Res Function(_$MerchantHomeScreen) _then)
      : super(_value, (v) => _then(v as _$MerchantHomeScreen));

  @override
  _$MerchantHomeScreen get _value => super._value as _$MerchantHomeScreen;
}

/// @nodoc

class _$MerchantHomeScreen extends MerchantHomeScreen {
  const _$MerchantHomeScreen() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$MerchantHomeScreen);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() customerHome,
    required TResult Function() merchantHome,
    required TResult Function() payment,
    required TResult Function() settings,
  }) {
    return merchantHome();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? customerHome,
    TResult Function()? merchantHome,
    TResult Function()? payment,
    TResult Function()? settings,
  }) {
    return merchantHome?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? customerHome,
    TResult Function()? merchantHome,
    TResult Function()? payment,
    TResult Function()? settings,
    required TResult orElse(),
  }) {
    if (merchantHome != null) {
      return merchantHome();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CustomerHomeScreen value) customerHome,
    required TResult Function(MerchantHomeScreen value) merchantHome,
    required TResult Function(PaymentScreen value) payment,
    required TResult Function(SettingsScreen value) settings,
  }) {
    return merchantHome(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(CustomerHomeScreen value)? customerHome,
    TResult Function(MerchantHomeScreen value)? merchantHome,
    TResult Function(PaymentScreen value)? payment,
    TResult Function(SettingsScreen value)? settings,
  }) {
    return merchantHome?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CustomerHomeScreen value)? customerHome,
    TResult Function(MerchantHomeScreen value)? merchantHome,
    TResult Function(PaymentScreen value)? payment,
    TResult Function(SettingsScreen value)? settings,
    required TResult orElse(),
  }) {
    if (merchantHome != null) {
      return merchantHome(this);
    }
    return orElse();
  }
}

abstract class MerchantHomeScreen extends SourceScreen {
  const factory MerchantHomeScreen() = _$MerchantHomeScreen;
  const MerchantHomeScreen._() : super._();
}

/// @nodoc
abstract class _$$PaymentScreenCopyWith<$Res> {
  factory _$$PaymentScreenCopyWith(
          _$PaymentScreen value, $Res Function(_$PaymentScreen) then) =
      __$$PaymentScreenCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaymentScreenCopyWithImpl<$Res>
    extends _$SourceScreenCopyWithImpl<$Res>
    implements _$$PaymentScreenCopyWith<$Res> {
  __$$PaymentScreenCopyWithImpl(
      _$PaymentScreen _value, $Res Function(_$PaymentScreen) _then)
      : super(_value, (v) => _then(v as _$PaymentScreen));

  @override
  _$PaymentScreen get _value => super._value as _$PaymentScreen;
}

/// @nodoc

class _$PaymentScreen extends PaymentScreen {
  const _$PaymentScreen() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PaymentScreen);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() customerHome,
    required TResult Function() merchantHome,
    required TResult Function() payment,
    required TResult Function() settings,
  }) {
    return payment();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? customerHome,
    TResult Function()? merchantHome,
    TResult Function()? payment,
    TResult Function()? settings,
  }) {
    return payment?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? customerHome,
    TResult Function()? merchantHome,
    TResult Function()? payment,
    TResult Function()? settings,
    required TResult orElse(),
  }) {
    if (payment != null) {
      return payment();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CustomerHomeScreen value) customerHome,
    required TResult Function(MerchantHomeScreen value) merchantHome,
    required TResult Function(PaymentScreen value) payment,
    required TResult Function(SettingsScreen value) settings,
  }) {
    return payment(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(CustomerHomeScreen value)? customerHome,
    TResult Function(MerchantHomeScreen value)? merchantHome,
    TResult Function(PaymentScreen value)? payment,
    TResult Function(SettingsScreen value)? settings,
  }) {
    return payment?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CustomerHomeScreen value)? customerHome,
    TResult Function(MerchantHomeScreen value)? merchantHome,
    TResult Function(PaymentScreen value)? payment,
    TResult Function(SettingsScreen value)? settings,
    required TResult orElse(),
  }) {
    if (payment != null) {
      return payment(this);
    }
    return orElse();
  }
}

abstract class PaymentScreen extends SourceScreen {
  const factory PaymentScreen() = _$PaymentScreen;
  const PaymentScreen._() : super._();
}

/// @nodoc
abstract class _$$SettingsScreenCopyWith<$Res> {
  factory _$$SettingsScreenCopyWith(
          _$SettingsScreen value, $Res Function(_$SettingsScreen) then) =
      __$$SettingsScreenCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SettingsScreenCopyWithImpl<$Res>
    extends _$SourceScreenCopyWithImpl<$Res>
    implements _$$SettingsScreenCopyWith<$Res> {
  __$$SettingsScreenCopyWithImpl(
      _$SettingsScreen _value, $Res Function(_$SettingsScreen) _then)
      : super(_value, (v) => _then(v as _$SettingsScreen));

  @override
  _$SettingsScreen get _value => super._value as _$SettingsScreen;
}

/// @nodoc

class _$SettingsScreen extends SettingsScreen {
  const _$SettingsScreen() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SettingsScreen);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() customerHome,
    required TResult Function() merchantHome,
    required TResult Function() payment,
    required TResult Function() settings,
  }) {
    return settings();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? customerHome,
    TResult Function()? merchantHome,
    TResult Function()? payment,
    TResult Function()? settings,
  }) {
    return settings?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? customerHome,
    TResult Function()? merchantHome,
    TResult Function()? payment,
    TResult Function()? settings,
    required TResult orElse(),
  }) {
    if (settings != null) {
      return settings();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CustomerHomeScreen value) customerHome,
    required TResult Function(MerchantHomeScreen value) merchantHome,
    required TResult Function(PaymentScreen value) payment,
    required TResult Function(SettingsScreen value) settings,
  }) {
    return settings(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(CustomerHomeScreen value)? customerHome,
    TResult Function(MerchantHomeScreen value)? merchantHome,
    TResult Function(PaymentScreen value)? payment,
    TResult Function(SettingsScreen value)? settings,
  }) {
    return settings?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CustomerHomeScreen value)? customerHome,
    TResult Function(MerchantHomeScreen value)? merchantHome,
    TResult Function(PaymentScreen value)? payment,
    TResult Function(SettingsScreen value)? settings,
    required TResult orElse(),
  }) {
    if (settings != null) {
      return settings(this);
    }
    return orElse();
  }
}

abstract class SettingsScreen extends SourceScreen {
  const factory SettingsScreen() = _$SettingsScreen;
  const SettingsScreen._() : super._();
}
